Maize scoring component
=======================

The previous two examples using REINVENT used Maize as the master process, but it is also possible to use the Maize scoring component in REINVENT 4 to have REINVENT call Maize instead. This might make it easier to incorporate certain workflows into existing (staged) learning pipelines.

We will again show off an active learning workflow, this time using relative free energy perturbation as the scoring method. This is a more complex workflow making use of the OpenFreeEnergy tool ecosystem, and using AutoDockGPU to generate the initial pose, together with RMSD filtering to only run FEP on suitable poses.

Scoring component
-----------------

The Maize scoring component can be used as follows:

.. code-block:: toml

   [[stage.scoring.component]]
   [stage.scoring.component.Maize]
   [[stage.scoring.component.Maize.endpoint]]
   name = "Maize"
   weight = 10.0

   # Score transformation settings - lower is better in this case
   transform.type = "reverse_sigmoid"
   transform.high = -15.0
   transform.low = -22.0
   transform.k = 0.5
   
   # Path to the maize executable - you can use your own or a global installation
   params.executable = "/path/to/maize.toml"
    
   # Path to the maize workflow
   params.workflow = "/path/to/workflow.yml"
    
   # Path to the maize config - this may be optional for you depending on the installation
   params.config = "/path/to/maize.toml"
    
   # Debug mode (not needed)
   params.debug = false
    
   # Keep graph data (not needed)
   params.keep = false
    
   # Workflow parameters you wish to overwrite
   params.parameters.n_oracle = 8
   params.parameters.reference = "/path/to/reference.sdf"
   params.parameters.ref_score = -19.539
   params.parameters.proxy_config = "/path/to/qptuna.json"
    
   # Logs (optional)
   params.log = "/path/to/maize.log"

Workflow parameters defined above take precedence over ones defined in the workflow file.

Workflow definition
-------------------

Our workflow will be used in a serialized format, it can be either JSON, YAML, or TOML, and can either be written by hand or generated from a python workflow object using :meth:`~maize.core.workflow.Workflow.to_file`. All workflows interfacing with REINVENT must feature a :class:`~maize.steps.mai.misc.ReinventEntry` and :class:`~maize.steps.mai.misc.ReinventExit` node. The former reads a JSON file generated by REINVENT including the generated SMILES codes and additional metadata and sends the SMILES to its output port (as ``list[str]``). The metadata currently only includes the current REINVENT iteration and is sent to the ``out_metadata`` port, this iteration is important for active learning workflows and is used to determine when to run warmup, pooling, or active learning stages. The latter node converts a list of molecules (as ``list[IsomerCollection]``) to a JSON file for REINVENT to read, including scores. What happens between these two nodes is up to the user, here, we use the active learning subgraph for single-execution workflows (:class:`~maize.steps.mai.misc.ActiveLearningSingle`):

.. code-block:: yaml

   name: al
   
   # This is a listing of all the required nodes in the graph
   nodes:
   
     # The entry node is always required
   - name: reinvententry
     type: ReinventEntry

     # This node converts the metadata information into a single integer
   - name: stripepoch
     type: StripEpoch

     # Converts the SMILES codes to molecules / isomers
   - name: smiles2molecules
     type: Smiles2Molecules

     # Runs active learning
   - name: activelearningsingle
     parameters:
       n_train: 128
     type: ActiveLearningSingle

     # Keeps track of active learning progress
   - name: progress
     parameters:
       save_epochs: true
     type: ActiveLearningProgressSingle

     # Active learning requires an acquisition function to determine which molecules get sent
     # to the oracle and which ones don't (all molecules always go to the surrogate model)
   - name: epsilongreedy
     parameters:
       epsilon: 0.2
       n_oracle: 8
     type: EpsilonGreedy

     # This is the scoring subgraph, FEP in our case
   - name: fep
     parameters:
       # This specific parameter is a custom python object representing settings to be used for batch submission
       batch_options: !!python/object:maize.utilities.execution.JobResourceConfig
         custom_attributes:
           constraint: volta
           gres: gpu:1
         exclusive_use: false
         walltime: '96:00:00'
       equilibration_length: 2000
       production_length: 5000
       isomer_filter: rmsd
       reference_charge_type: ref
       n_repeats: 1
       trial: false
     type: FEP

     # The exit node is always required
   - name: reinventexit
     type: ReinventExit
   
   # Channel declaration
   channels:
   - receiving:
       smiles2molecules: inp
     sending:
       reinvententry: out
   - receiving:
       stripepoch: inp
     sending:
       reinvententry: out_metadata
   - receiving:
       activelearningsingle:
         map: inp
     sending:
       stripepoch: out
   - receiving:
       activelearningsingle:
         epoch: inp
     sending:
       smiles2molecules: out
   - receiving:
       progress: inp
     sending:
       activelearningsingle:
         merge-all: out
   - receiving:
       reinventexit: inp
     sending:
       progress: out
   - receiving:
       fep:
         autodockgpu: inp
     sending:
       activelearningsingle:
         filecachedmol: out_calc
   - receiving:
       activelearningsingle:
         filecachedmol: inp_calc
     sending:
       fep:
         makeabsolute: out
   - receiving:
       epsilongreedy: inp
     sending:
       activelearningsingle:
         qptunapredict: out
   - receiving:
       activelearningsingle:
         multiplex: inp
     sending:
       epsilongreedy: out_oracle
   - receiving:
       activelearningsingle:
         al:
           merge-all: inp
     sending:
       epsilongreedy: out_surrogate
   
   # A listing of all relevant parameters - all of these can be overwritten from
   # the REINVENT scoring component or the commandline if the workflow is run alone.
   parameters:
   # The first two parameters are always required to be in this exact format and allow REINVENT to communicate with Maize using JSON files.
   - map:
     - reinvententry: data
     name: inp
   - map:
     - reinventexit: data
     name: out

   # Determines the number of warmup, pooling, and active learning rounds, respectively. -1 indicates infinity, in our case REINVENT will decide when to stop iterating.
   - map:
     - activelearningsingle: epochs
     name: epochs
     value: [0, 1, -1]

     # Proxy / surrogate model settings: Configuration (required), and location of temporary files
   - map:
     - activelearningsingle: proxy_config
     name: proxy_config
     value: qptuna.json
   - map:
     - activelearningsingle: proxy_model
     name: proxy_model
     value: temp/model.pkl
   - map:
     - activelearningsingle: proxy_pool
     name: proxy_pool
     value: temp/pool.csv
   - map:
     - activelearningsingle: proxy_build
     name: proxy_build
     value: temp/build.json
   - map:
     - activelearningsingle: cache
     name: cache
     value: temp/cache.pkl

     # Number of molecules to use for retraining during active learning
   - map:
     - activelearningsingle: n_train
     name: n_train
     value: 256

     # The number of molecules to send to the oracle (FEP) every iteration
   - map:
     - epsilongreedy: n_oracle
     name: n_oracle
     value: 8

     # The proportion to sample randomly - this is unique to epsilon greedy
   - map:
     - epsilongreedy: epsilon
     name: epsilon
     value: 0.2

     # Where to save useful information
   - map:
     - progress: save_location
     name: save_location
     value: dumps

     # How long in ps to equilibrate FEP simulations
   - map:
     - fep: equilibration_length
     name: equilibration_length
     value: 2000

     # How long in ps to run production replica exchange
   - map:
     - fep: production_length
     name: production_length
     value: 5000

     # The grid file for docking
   - map:
     - fep: grid_file
     name: grid
     value: path/to/grid.maps.fld

     # The reference compound xtal pose for RMSD filtering and absolute free energy conversion
   - map:
     - fep: reference
     name: reference
     value: path/to/reference.sdf

     # The reference binding free energy
   - map:
     - fep: ref_score
     name: ref_score
     value: -19.539

     # The protein structure
   - map:
     - fep: protein
     name: protein

     # Location to dump FEP data (for debugging)
   - map:
     - fep: dump_to
     name: dump_to
     value: dumps


Running
-------

Running the workflow can be accomplished with:

.. code-block:: bash

   reinvent -f toml reinvent.toml
